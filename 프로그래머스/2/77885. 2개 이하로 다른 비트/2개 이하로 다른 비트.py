def solution(numbers):
    answer = []
    for num in numbers:
        # num이 짝수인 경우
        if num % 2 == 0:
            # 가장 오른쪽 비트가 0이므로, +1하면 비트가 1개만 바뀐다.
            answer.append(num + 1)
        # num이 홀수인 경우
        else:
            # num보다 크면서 비트가 1-2개 다른 가장 작은 수를 찾아야 한다.
            # 이는 이진수에서 가장 오른쪽에 있는 '0'을 '1'로 바꾸고,
            # 그 바로 오른쪽 '1'을 '0'으로 바꾸는 것과 같다.
            # 예: 0...0111(7) -> 0...1011(11)
            # 이 연산은 결과적으로 (가장 오른쪽 '0'의 자리값) / 2 만큼 더하는 것과 같다.
            
            # 가장 오른쪽 0의 위치(자리값)를 찾는다.
            # 1. num과 num+1을 XOR 연산하면 가장 오른쪽 '0'과 그 오른쪽의 '1'들이 모두 1로 바뀐다.
            #    ex) num=7(0111), num+1=8(1000) -> 7^8 = 15(1111)
            # 2. 여기서 오른쪽으로 1 쉬프트하고 1을 더하면 가장 오른쪽 '0'의 자리값만 남는다.
            #    ex) 15>>1 = 7(0111) -> 7+1 = 8(1000)
            rightmost_zero_pos = ((num ^ (num + 1)) >> 1) + 1
            
            # 원래 수에 (가장 오른쪽 0의 자리값 / 2)를 더한다.
            result = num + (rightmost_zero_pos // 2)
            answer.append(result)
            
    return answer